# Blast

Главные компоненты это GameField, AnimationState, GemsState, Cell, остальные это плюс-минус утилиты.

GemsState - это объект, который хранит в себе максимально чистые платонические идеи. Он ничего не делает, просто содержит массив цветов на поле, у этого объекта можно спрашивать, какой камень, в какой клетке лежит

GameField - это объект, который отвечает за все взаимодействия с пользователем, разрушение и добавление камней, начисление очков. В общем, земский начальник бизнес логики. Прежде чем начать игру надо настроить этот объект и после этого вызвать у него метод start(). В настройки, кроме прочего передаются GemsState и AnimationsState. Именно их он опрашивает, чтобы получать текущие данные и принимать решения.

Cell - набор объектов, которые отвечают за визуальное отображение поля. Каждый Cell отвечает за одну клетку. Можно воспринимать их как пиксили монитора, только каждый пиксель это клетка на поле. При этом им позволено переносить свой Sprite далеко за пределы своей клетки, благодаря чему, например, возможна анимация обмена двух камней и проч. Все они создаются GameField-ом (вместо этого их мог бы создавать и отвечать за них AnimationState или ещё какой класс, но я решил, что лучше оставить Cell-ы геймфилду. Геймфилд любит работать со статичными данными, с клетками, у которых есть конкретные координаты, Cell как раз подходит. А AnimationState создан для работы со всякими отбросами, которые не знают в какой они клетке).

AnimationState - с ним хитрее. Если GemsState нужен для хранения самой важной для геймплея информации, Сell для отображения, то AnimationState отвечает за сложные анимации. Почему? А вот вопрос: если сломать камень в нижнем ряду, то верхние должны начать падать. Фактически падение это анимация, то есть это визуальная часть. Вдруг в будущем мы захотим, чтобы они падали виляя влево-вправо? тогда все модули, которые надеялись на чёткое и ровное падение сломаются... Логикой игры являются только целые координаты клеток. Однако! падающий камень однажды должен приземлится и стать нормальным камнем (этим влияя на геймплей), получается, что падающий камень это тоже объект геймплея. Как кот Шредингера, анимированный камень это чистейший визуал, который НЕ должен вмешиваться в бизнес-логику но при этом же и должен одновременно. В обшем решение я выбрал такое: AnimationState отвечает за всю грязь, то есть за всё, что сейчас является визуалом, но в будущем повлияет на игровое поле, например падающий камень или камень, перелетающий в новую позицию. При этом, если спросить его, что находится в клетке (x, y), то он попытается найти подходящий камень в этой клетке. Это сделано, чтобы проще было работать с летающими камнями и не искать их повсюду. Разные анимированные камни могут по разному захотеть работать с этой особенностью, например падающий камень не боится сдвигаться вниз, благодаря этому всегда понятно до какой клетки он долетел, а SwappingGem притворяется, что он никуда не сдвигался, и предпочитает сдвигать спрайт, а не своё настоящее положение, благодаря этому его старое место не занимают пока он не долетит до цели

Получается примерно такая схема:

создаём отдельно GemsState, GameField, AnimationsState
передаём в GameField ссылки на GemsState и AnimationsState. GameField затем создаёт в для каждой клетки Cell, передаёт ему колбек, который надо вызвать если по Cell кто-то тыкнет. игрок тыкает в Cell, Cell вызывает колбек, этим сообщая GameField-у что был тык. GameField, если находится в ожидании инпута, опбрабатывает этот клик, опрашивая GemsState и AnimationState. Вполне возможно, что GameField прикажет GemsState-у что-то сделать/удалить или скажет AnimationState-у начать анимацию (например уронить подвисший в воздухе камень). При этом AnimationState не позволяет за него оканчивать анимацию, он сам лучше знает когда когда стоит. AnimationState делает анимации, а когда анимации окончатся, он оповестит (через колбек) GameField об этом. В каждом кадре GameField просит Cell-ов обновляться, те смотрят на состояние дел в GemsState и AnimationsState и рисуются согласно этому

Новые бонусы добавляются в GameField через метод addBonus.
Новые виды анимаций добавляются в AnimationsState через метод addAnimationType.

Также я много использовал HTML/CSS, это как бы хорошо, потому что css позволяет быстро делать более гибкую верстку, но это же и трудность, так как html неудобно связывать с модулями из вебпака. Скрипты, вызываемые из HTML заполняют глобальную область видимости, чем я и воспользовался. HTML-сторона создаёт глобальный объект dom, если какой-либо модуль вебпака хочет обратиться к HTML-стороне, то он обращается к объекту dom. В случаях, когда сам dom должен обращаться к модулям, я инвертировал зависимости (в dom-объект можно зарегистрировать события, например для нажатия кнопок).

## Запуск

Требуется Node-js

```sh
npm install
npm run build
npm start
```